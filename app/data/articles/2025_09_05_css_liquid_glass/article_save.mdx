---
title: Recreating Apple Liquid Glass with CSS & SVG
slug: css-liquid-glass
description: Explore how to recreate Apple's stunning Liquid Glass effect using CSS, SVG Displacement Maps, and refraction calculations.
date: 2025-09-06
---

import { Checkbox } from "./Checkbox";
import { DisplacementVectorField } from "./DisplacementVectorField";
import { RayRefractionSimulation } from "./RayRefractionSimulation";
import { RefractionAnglesExplanation } from "./RefractionAnglesExplanation";
import { RefractionDetail } from "./RefractionDetail";
import { Slider } from "./Slider";
import { VectorToRedGreen } from "./VectorToRedGreen";
import { VideoHero } from "./VideoHero";

<VideoHero />

# Introduction

Apple introduced the “Liquid Glass” effect during WWDC 2025 in June. This piece is a hands‑on exploration of how to recreate a similar, physics‑inspired UI effect on the web using CSS, SVG displacement maps, and refraction math. Over a decade ago I wrote a tiny [raytracer](https://www.youtube.com/watch?v=1JoTZg4Ulo0) at school (42); it only did reflections, but it planted the seed for my curiosity about how light bends.

Rather than chase pixel‑perfect fidelity with Apple’s implementation, the goal here is to understand the phenomenon (refraction) well enough to build an expressive, tweakable system you can repurpose.

## Liquid Glass – Visual Reference

Below are placeholder slots for captures of the real effect (drop in screenshots / short looped videos):

<div className="grid grid-cols-3 gap-4 my-6">
  <figure className="aspect-video rounded-lg bg-slate-500/10 dark:bg-slate-300/10 flex items-center justify-center text-xs text-slate-500 dark:text-slate-400">
    Reference 1
  </figure>
  <figure className="aspect-video rounded-lg bg-slate-500/10 dark:bg-slate-300/10 flex items-center justify-center text-xs text-slate-500 dark:text-slate-400">
    Reference 2
  </figure>
  <figure className="aspect-video rounded-lg bg-slate-500/10 dark:bg-slate-300/10 flex items-center justify-center text-xs text-slate-500 dark:text-slate-400">
    Reference 3
  </figure>
</div>

We’ll now build up the effect from first principles—starting with how light bends.

# Understanding Refraction

Refraction is the bending of light as it passes through different mediums. In the context of Liquid Glass, it creates a visually appealing distortion effect that mimics how light interacts with real glass.
The effect is achieved by calculating the angle of refraction using Snell's Law, which states:

$$
n_1 \sin(\theta_1) = n_2 \sin(\theta_2)
$$

<div className="text-base grid grid-cols-[65%_35%] gap-1 p-7">

$$n_1 = \text{refractive index of first medium}$$

$$\theta_1 = \text{angle of incidence}$$

$$n_2 = \text{refractive index of second medium}$$

$$\theta_2 = \text{angle of refraction}$$

</div>

<RefractionAnglesExplanation />

For simplicity, here we restrict to:

- only one refraction (we do not calculate what happens when the light exits the glass, even if it goes out),
- Only top surface has shape, bottom of glass is flat.
- We asjut thickness of the glass, but glass is always on the surface it refracts (so no need to calculate the second refraction when ray exits the glass)
- We assume the incident ray is always in Air (refractive index of air is ~1).
-

Bezel Height and Bezel Width:

For now, we assume bezel height = bezel width. This allows us

Symmetry

Because our shapes are symmetric, we can simplify our calculations by only considering the top half of the glass. The bottom half will mirror the top half.

## Visual Explanation

<RayRefractionSimulation
  bezelHeightFn={(x) => Math.sqrt(1 - (1 - x) ** 2)}
  bezelWidth={100}
  glassWidth={400}
  glassHeight={200}
/>

<RayRefractionSimulation
  bezelHeightFn={(x) => 1 - Math.sqrt(1 - (1 - x) ** 2)}
  bezelWidth={100}
  glassWidth={400}
  glassHeight={200}
/>

## Converting to a Displacement Vector Field

Now that we know how to calculate the displacement at a distance from border, let's calculate the displacement vector field for the entire glass surface.

<DisplacementVectorField />

<VectorToRedGreen />

## Building the SVG Filter

Now that we understand the basics of refraction, we can create an SVG filter to apply the Liquid Glass effect. The filter will use a displacement map to distort the background based on the calculated refraction angles.

### What is a Displacement Map?

A displacement map is an image that defines how pixels in a target image should be displaced. In our case, we will use a displacement map to create the distortion effect of the Liquid Glass.

Displacement maps are typically images with each pixel encoding a vector in multiple channels (e.g., RGB).

SVG's `<feDisplacementMap />` encodes these pixels in a 32 bit RGBA image, where each channel represents a different axis of displacement.

It's up to the user to define which channel corresponds to which axis, but it is important to understand the constraint:
Because each channel is 8 bits, the displacement is limited to a range of -128 to 127 pixels in each direction. (256 values possible in total).
128 is the neutral value, meaning no displacement.

Because we want this to be dynamic, we will compute the map on the client-side in a `<canvas />`, and use a `<feImage/>` to load the displacement map into the filter.

```tsx
<svg color-interpolation-filters="sRGB">
  <filter id={id}>
    <feImage
      href={displacementMapDataUrl}
      x={0}
      y={0}
      width={width}
      height={height}
      result="displacement_map"
    />
    <feDisplacementMap
      in="SourceGraphic"
      in2="displacement_map"
      scale={scale}
      xChannelSelector="R" // Red Channel for displacement in X axis
      yChannelSelector="G" // Green Channel for displacement in Y axis
      result="displaced"
    />
  </filter>
</svg>
```

### Simple Concave Glass

<RefractionDetail
  equationFn={(x) => Math.sqrt(1 - (1 - x) ** 2)}
  equationRender={`<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>y</mi><mo>=</mo><msqrt><mrow><mi>x</mi><mo>(</mo><mn>2</mn><mo>-</mo><mi>x</mi><mo>)</mo></mrow></msqrt></math>`}
/>

### Simple Convex Glass

<RefractionDetail
  equationFn={(x) => 1 - Math.sqrt(1 - (1 - x) ** 2)}
  equationRender={`<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>y</mi><mo>=</mo><mn>1</mn><mo>-</mo><msqrt><mrow><mi>x</mi><mo>(</mo><mn>2</mn><mo>-</mo><mi>x</mi><mo>)</mo></mrow></msqrt></math>`}
/>

### Complex Glass with Distortion

If you want to understand a bit more about why refraction works like this, check out this [video by Veritasium about Infinite Paths](https://www.youtube.com/watch?v=qJZ1Ez28C-A). Though what we'll do here is simply applying Snell's Law to calculate the refraction angle based on the incident angle and the refractive index of the glass.

## Adding Specular

To enhance the Liquid Glass effect, we can add a specular highlight that simulates the reflection of light on the glass surface. This can be achieved using CSS properties like `box-shadow` or `filter: brightness()` to create a shiny appearance.

## Switch and Slider

Switch and Slider are a special case, in the sense that

## Tools and Techniques

- Using CSS for styling and animations.
- Leveraging SVG Displacement Maps for distortion.
- Calculating refraction with Snell's Law.

## Creating the components

- Setting up the SVG structure.
- Applying CSS for visual styling.
- Integrating the Displacement Map.
- Calculating and visualizing refraction.

<RefractionDetail
  equationFn={(x) => {
    const circle = Math.sqrt(1 - (1 - x * 2) ** 2);
    const sin = Math.cos((x + 0.5) * 2 * Math.PI) / 40 + 0.5;
    const smootherstep = 6 * x ** 5 - 15 * x ** 4 + 10 * x ** 3;
    const ratioCircle = 1 - smootherstep;
    return circle * ratioCircle + sin * (1 - ratioCircle);
  }}
  equationRender={`<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>y</mi><mo>=</mo>
  <mrow>
    <mn>2</mn><mo>&#xA0;</mo><msqrt><mrow><mi>x</mi><mo>(</mo><mn>1</mn><mo>-</mo><mi>x</mi><mo>)</mo></mrow></msqrt>
    <mo>&#x22C5;</mo>
    <mrow>
      <mn>1</mn><mo>-</mo>
      <mrow>
        <mn>6</mn><msup><mi>x</mi><mn>5</mn></msup>
        <mo>-</mo>
        <mn>15</mn><msup><mi>x</mi><mn>4</mn></msup>
        <mo>+</mo>
        <mn>10</mn><msup><mi>x</mi><mn>3</mn></msup>
      </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
      <mrow>
        <mn>0.5</mn>
        <mo>-</mo>
        <mfrac>
          <mrow><mi>cos</mi><mo>(</mo><mn>2</mn><mi>&#x03C0;</mi><mi>x</mi><mo>)</mo></mrow>
          <mn>40</mn>
        </mfrac>
      </mrow>
      <mo>&#x22C5;</mo>
      <mrow>
        <mn>6</mn><msup><mi>x</mi><mn>5</mn></msup>
        <mo>-</mo>
        <mn>15</mn><msup><mi>x</mi><mn>4</mn></msup>
        <mo>+</mo>
        <mn>10</mn><msup><mi>x</mi><mn>3</mn></msup>
      </mrow>
    </mrow>
  </mrow>
</math>`}
/>

And now by tweaking the parameters, we can approximate the behavior of the Switch and Slider components.

<Checkbox />

<Slider />

## Challenges and Solutions

- Common issues with SVG filters.
- Ensuring mathematical accuracy in refraction.

## Conclusion

- Recap of the process.
- Potential applications of the technique.

---

Stay tuned for the full implementation details and code snippets!
