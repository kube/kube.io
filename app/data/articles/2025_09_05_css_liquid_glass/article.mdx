---
title: Recreating Apple Liquid Glass with CSS & SVG
slug: css-liquid-glass
description: Explore how to recreate Apple's stunning Liquid Glass effect using CSS, SVG Displacement Maps, and refraction calculations.
date: 2025-09-06
---

import { Checkbox } from "./Checkbox";
import { DisplacementVectorField } from "./DisplacementVectorField";
import { DisplacementVectorFieldToRGMap } from "./DisplacementVectorFieldToRGmap";
import { RayRefractionSimulation } from "./RayRefractionSimulation";
import { RefractionAnglesExplanation } from "./RefractionAnglesExplanation";
import { RefractionDetail } from "./RefractionDetail";
import { Slider } from "./Slider";
import { VectorToRedGreen } from "./VectorToRedGreen";
import { VideoHero } from "./VideoHero";

<VideoHero />

# Introduction

Apple [introduced the Liquid Glass effect during WWDC 2025](https://www.youtube.com/watch?v=jGztGfRujSE) in June. This piece is a hands‑on exploration of how to recreate a similar, physics‑inspired UI effect on the web using CSS, SVG displacement maps, and refraction math. Over a decade ago I wrote a tiny [raytracer](https://www.youtube.com/watch?v=1JoTZg4Ulo0) at school; it only did reflections, but it planted the seed for my curiosity about how light bends.

Instead of chasing pixel‑perfect parity, we’ll approximate Liquid Glass, recreating the core refraction and a specular highlight, as a focused proof‑of‑concept you can extend.

We’ll now build up the effect from first principles—starting with how light bends.

> Note: The demo at the end of this article only works in Chrome.

# Understanding Refraction

Refraction is the change in direction (bending) of a wave (in our case a light wave) as it passes between media with different refractive indices, caused by a change in propagation speed.
The relationship between the incident and refracted angles is given by Snell's Law:

<div className="pt-6 w-full flex justify-center">
  $$ n_1 \sin(\theta_1) = n_2 \sin(\theta_2) $$
</div>

<div className="text-base grid grid-cols-1 sm:grid-cols-[65%_35%] gap-1 p-7">

$$n_1 = \text{refractive index of first medium}$$

$$\theta_1 = \text{angle of incidence}$$

$$n_2 = \text{refractive index of second medium}$$

$$\theta_2 = \text{angle of refraction}$$

</div>

<RefractionAnglesExplanation />

When light travels from a higher refractive index medium into a lower one, Snell's Law eventually has no real solution beyond a critical angle: the wave undergoes total internal reflection instead of refracting out. To keep things focused we avoid that branch of behavior by constraining the scenario. We will:

- Treat the ambient medium as air with index 1.
- Use materials with refractive index > 1 (so rays always enter the higher index first).
- Consider only a single refraction event (ignore any later exit / second refraction).
- Assume incident rays start orthogonal to the background plane.

Under these assumptions every ray we care about has a well-defined refracted direction via Snell's Law, and we can postpone handling internal reflection or multi-interface paths.

> If you want to understand a it more about why refraction works like this, check out this [video by Veritasium about Infinite Paths](https://www.youtube.com/watch?v=qJZ1Ez28C-A). Though what we'll do here is simply applying Snell's Law to calculate the refraction angle based on the incident angle and the refractive index of the glass.

## Limitations in this project

We will also simplify the geometry of any refracting object:

- Objects are defined by a 2D footprint (plan shape) that lies in a plane strictly parallel to the background. (No 3D shapes, no perspective).
- There is no physical gap between the object and the background plane (they are in contact).
- Two parameters can vary: its bezel (edge transition) and its thickness (peak height above the background).

Surface height across the bezel is described by a single, continuous, differentiable function f over the normalized interval [0,1]. Because incoming rays are orthogonal to the background, the height at a point depends only on its normalized inward distance from the object's outer border. We call this distanceFromSide, defined as the ratio between the start of the bezel (0 at the outer border) and the end of the bezel (1 where the bezel transitions to the flat interior).

```ts
const height = f(distanceFromSide);
```

From the height we can calculate the angle of incidence, which is the angle between the incoming ray and the normal to the surface at that point. The normal is simply the derivative of the height function at that point, rotated by -90 degrees:

```ts
const delta = 0.001; // Small value to approximate derivative
const y1 = f(distanceFromSide - delta);
const y2 = f(distanceFromSide + delta);
const derivative = (y2 - y1) / (2 * delta);
const normal = { x: -derivative, y: 1 }; // Derivative, rotated by -90 degrees
```

> TODO: Merge these two next interactive graphs into one, and animate:
>
> - [ ] The surface height drawing (to make people understand how the height function works)
> - [ ] The ray refraction simulation (to show how the angle of incidence is calculated)
> - [x] Change the height function to show how it affects the refraction

<RayRefractionSimulation glassWidth={400} glassHeight={200} />

You can see in the above simulations that in concave surfaces, the light ray can go outside of the glass, while in convex surfaces it always stays inside.

Displacing the ray OUTSIDE of the object is less performant, and Apple seems to only do convex surfaces (with the exception of the Switch and Slider components, which we will cover later). It is important then to understand that the final displacement will be less performant if we try to simulate concave surfaces.

# Displacement Vector Field

Now that we know how to calculate the displacement at a distance from border, let's calculate the displacement vector field for the entire glass surface.

The vector field here just describes at every position on the glass surface how much the light ray is displaced from its original position. This displacement is a vector calculated based on the angle of incidence and the refractive index of the glass.

The translational symmetry along the edge normal allows us to re-use the same displacement magnitudes all around the bezel.
The only constraint being that the displacement vector will be oriented along the normal at the border.

<DisplacementVectorField />

```ts
displacementVector = {
  angle: normalOfBorder,
  magnitude: displacementMagnitude, // Calculated based on the angle of incidence and refractive index
};
```

# SVG Displacement Map

## What is a Displacement Map?

A displacement map is an image that defines how pixels in a target image should be displaced. In our case, we will use a displacement map to create the distortion effect of the Liquid Glass.

Displacement maps are typically images with each pixel encoding a vector in multiple channels (e.g., RGB).

SVG's `<feDisplacementMap />` encodes these pixels in a 32 bit RGBA image, where each channel represents a different axis of displacement.

It's up to the user to define which channel corresponds to which axis, but it is important to understand the constraint:
Because each channel is 8 bits, the displacement is limited to a range of -128 to 127 pixels in each direction. (256 values possible in total).
128 is the neutral value, meaning no displacement.

SVG filters can only use images as displacement maps, so we need to convert our displacement vector field into an image format.

```tsx
<svg color-interpolation-filters="sRGB">
  <filter id={id}>
    <feImage
      href={displacementMapDataUrl}
      x={0}
      y={0}
      width={width}
      height={height}
      result="displacement_map"
    />
    <feDisplacementMap
      in="SourceGraphic"
      in2="displacement_map"
      scale={scale}
      xChannelSelector="R" // Red Channel for displacement in X axis
      yChannelSelector="G" // Green Channel for displacement in Y axis
    />
  </filter>
</svg>
```

`<feDisplacementMap />` uses the red channel for the X axis and the green channel for the Y axis. The blue and alpha channels are ignored.

## Scale

Red and Green channel values, used respectively for X-axis and Y-axis displacement, are 8 bits (0-255), and without scale only means:

$$
\begin{aligned}
0 &\mapsto -1 \\
128 &\mapsto 0 \\
255 &\mapsto 1
\end{aligned}
$$

The `scale` attribute of `<feDisplacementMap />` defines how much the displacement is scaled. So if we set `scale`, the displacement will be:

$$
\begin{aligned}
0 &\mapsto -scale \\
128 &\mapsto 0 \\
255 &\mapsto scale
\end{aligned}
$$

Because we normalized our vectors with maximum possible displacement as unit, we can re-use this maximum displacement as scale:

```tsx
<feDisplacementMap
  in="SourceGraphic"
  in2="displacement_map"
  scale={maximumDisplacement} // Maximum displacement in pixels
  xChannelSelector="R"
  yChannelSelector="G"
/>
```

This `scale` property can also be used for animating the displacement effect, without having to recalculate anything, even if not physically accurate.

## Vector to Red-Green values

To convert our displacement vector field into a displacement map, we need to convert each vector into a color value. The red channel will represent the X component of the vector, and the green channel will represent the Y component.

We currently have polar coordinates (angle and magnitude) for each vector, so we need to convert them to Cartesian coordinates (X and Y) before mapping them to the red and green channels.

```tsx
const x = Math.cos(angle) * magnitude;
const y = Math.sin(angle) * magnitude;
```

Because we normalised our vectors already, `magnitude` here is between 0 and 1.

From here, we just remap the values to the range of 0 to 255 for the red and green channels:

<VectorToRedGreen />

```tsx
const result = {
  r: 128 + x * 127, // Red channel is the X component, remapped to 0-255
  g: 128 + y * 127, // Green channel is the Y component, remapped to 0-255
  b: 128, // Blue channel is ignored
  a: 255, // Alpha channel is fully opaque
};
```

After converting every vector in the map to color value, we get an image that can be used as a displacement map in the SVG filter.

## Playground

<RefractionDetail
  equationFn={(x) => Math.sqrt(1 - (1 - x) ** 2)}
  equationRender={`<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mi>y</mi><mo>=</mo><msqrt><mrow><mi>x</mi><mo>(</mo><mn>2</mn><mo>-</mo><mi>x</mi><mo>)</mo></mrow></msqrt></math>`}
/>

# Creating Components

## SVG Filter as `backdrop-filter`

> This is a Chrome-specific feature, as it allows SVG filters to be used as `backdrop-filter`.
> This is not in the CSS spec, but due to Chrome's implementation of the CSS Filter Effects Module.
>
> For above renderings, we used the `filter` to make viewable in Safari and Firefox.
> For the next components, we will use `backdrop-filter` to allow the effect to be applied to the background, which limit to Chrome for now.

To apply the Liquid Glass effect to a component, we can use the SVG filter as a `backdrop-filter`. This allows us to apply the displacement effect to any element that has a background.

```css
.glass-panel {
  backdrop-filter: url(#liquidGlassFilterId);
}
```

Now that we have all the pieces in place, we can create components that use this effect.

## Switch

Switch uses a lipped bezel, which is a bit more complex than the simple convex bezel we used for the glass panel.

The lip makes the surface convex on the outside and concave in the middle, which make the center slider zoomed out, while the edges refract the inside.

<Checkbox />

## Slider

Slider re-uses the same logic as the Switch, and lets user see the current value of the slider behind the thumb glass.

<Slider />

# Conclusion

This proof‑of‑concept reconstructs the core of Apple’s Liquid Glass look by focusing on refraction and a displacement workflow using pure CSS + SVG. While it already yields a convincing, extensible effect, today it’s Chrome‑only because Chrome uniquely lets SVG filters act as backdrop-filter.

The approach is intentionally minimal, to make it easy to understand and extend. The core steps are:

$$
surface → normals → refraction → vector field → displacement map
$$

Each step is swappable (better height functions, different optical models, added highlights).

## When to Use

- Polished glassy panels, HUD cards, controls needing subtle depth.
- Interfaces where motion + distortion can guide attention.
- Electron applications, or every runtime that can afford Chrome‑only features.

## Fallbacks for Non-Chrome Browsers

Provide a graceful static blur / translucency for browsers without SVG backdrop support.

## Next Steps

- Add squircle / organic bezel profiles.
- Optimize: replace base64 intermediates with SVG filter stages.
- Expand component set (Switch, Slider) with parameter presets.
- Support arbitrary shapes.

## Performance Notes

- Stay convex when possible; concave geometries increase overdraw and cost.
